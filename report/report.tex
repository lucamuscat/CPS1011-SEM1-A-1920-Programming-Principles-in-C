
% Fix formatting errors in class jsonWriter pg114 lst 41
%fix formatting listing 40
%should code also have onehalfline spacing?

\documentclass[a4paper, 12pt, titlepage]{article}

%---------------Preamables---------------
\usepackage[none]{hyphenat}
\usepackage{tikz}
\usepackage{aeguill}
\usepackage{setspace}
\usepackage{listings}
\usepackage[newfloat]{minted}
\usepackage[justification=centering]{caption}
\usepackage[margin=0.78in]{geometry}
\usepackage{titlesec}
\usepackage{graphicx}
\usepackage{float}
\usepackage{multirow}
\usepackage{tabularx}
\usepackage{longtable}
\usepackage{hyperref}

\setlength{\footnotesep}{\baselineskip}

\newcolumntype{L}[1]{>{\raggedright\arraybackslash}p{#1}}
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}
\newcolumntype{R}[1]{>{\raggedleft\arraybackslash}p{#1}}
\newenvironment{code}{\captionsetup{type=listing}}{}
% \sourcecode{Directory/NameOfFile}{Caption}{Label}
% #1: Code Snippet
% #2: Caption
% #3: Reference Label
\newcommand{\sourcecode}[3]{
    \begin{code}
      \inputminted[linenos,numbersep=5pt,gobble=0,frame=lines,framesep=2mm,]{c}{#1}
        \caption{#2}
        \label{lst: #3}
    \end{code}
  }

\newcommand{\explainline}[2]{
  \textbf{Line #1} & #2 \\ \\
}

% #1 - Scale
% #2 - Image path
% #3 - Caption
% #4 - Reference Label
\newcommand{\image}[4]{
  \begin{figure}[!h]
  \centerline{\includegraphics[scale=#1]{#2}}
  \end{figure}
  \captionof{figure}{#3}
   \label{fig: #4}
}
%---------------  End   ---------------

\begin{document}

%---------------Header---------------
%Good Syntax styles: trac, abap
\title{C Assignment Report}
\author{Luca Muscat}

\titleformat{\section}{\Large\bfseries\filcenter}{}{0em}{}
\titleformat{\subsection}{\normalsize\bfseries\filcenter}{}{0em}{}
\titleformat{\subsubsection}{\small\bfseries}{}{0em}{}
\maketitle

\pagebreak
\tableofcontents
\pagebreak
%---------------   End  ----------------

%--------------- Content ---------------
\begin{onehalfspacing}
  \section{Task 1}
  \label{sec:task1}
  In this task, a number of array-manipulating functions will have to be implemented. The functions which were implemented are as follows:

  \begin{enumerate}

  \item generate(): A function that populates an array with a
      sequence of N integers, in ascending order, and starting off integer i
      having a minimum value of 1. \emph{i} should be accepted as a function
      argument while N is defined as a constant. This function is
      destructive in the sense that it overwrites any previously generated
      values.
    \item shuffle(): A function that shuffles the items of an array
      argument and which makes use of stdlib.hâ€™s rand() function.
    \item sort(): A function (implemented from scratch) that returns a
sorted array passed as an argument
\item shoot(): A function that zeros out one element from,
  a possibly unsorted, array at random. This function returns an error
  if at least one element had already been previously zeroed out.
\item target(): A function that returns the number
  (i.e. the actual value and not the array offset) that was zeroed out
  by a single call to shoot().

  \end{enumerate}
  \pagebreak
  \subsection{Task 1a}
  In this task, the functions listed in section \ref{sec:task1} will
  be implemented. For the sake of readability, the functions were split
  into two files which are the ``functions.h'' (which holds the function
  prototypes and their description via comments) file and
  ``functions.c'' which contains function's implementations.



  \subsubsection{struct myint\_t}
  A structure called \emph{myint\_t}, which contains an int array called \emph{nums} of size N and another int variable called \emph{shoot\_value}.
  Due to the nature of the \emph{shoot()} and \emph{target()} functions, the best way to keep track of what value has been shot out is by keeping the shot value (value from the filled nums array picked by random by \emph{shoot()}) tied together with the array it got shot out of. This way, for every int array created, a \emph{shoot\_value} will be associated with it.

\sourcecode{snippets/myint_t.c}{myint\_t implementation}{myint_t}

A helper function was also created to help with the creation of \emph{myint\_t} variables. Really and truely all this function does is return a \emph{myint\_t} variable with its \emph{shoot\_value} set to -1 (-1 will signify a null).

\sourcecode{snippets/myint_t_create_t.c}{Helper function.}{create_t}

\clearpage

  \subsubsection{generate()}
  The generate function generate a sequence of consequetive numbers starting from i (the minimum number provided by the user which has to be a value above 0). Kindly note that the constant N is defined in utils.h

  \sourcecode{snippets/generate_header.c}{Generate Function Prototypes}{int_generate_header}

  In lines 2 and 3 of listing \ref{lst: int_generate_implementation}, a conditional statement was added to keep the user from providing a number smaller than 1. Line 11 implements a basic overflow handling mechanism which checks that i is not in range of overflowing. Inside of this conditional statement, a simple for loop is used to populate the array.

  \sourcecode{snippets/generate_implementation.c}{Generate Function Implementation}{int_generate_implementation}

  \subsubsection{shuffle()}
  The shuffle function implements the Fisher-Yates algorithm which is a basic shuffle algorithm\footnote{Fisher-Yates Shuffle Algorithm Wikipedia: \url{https://en.wikipedia.org/wiki/Fisher\%E2\%80\%93Yates_shuffle}}. In short, i starts at the end of the array and is also used as a bound. With every iteration, \emph{i} is decremented, reducing the possible range of random numbers which can be generated. Once a random number is generated, the element at i will be swapped with the random number. The following is an implementation of the fisher-yates shuffle algorithm. Kindly note that the random function used can be found in the \emph{utils.c} file.

  \clearpage

  \sourcecode{snippets/int_shuffle_header.c}{Shuffle function prototype}{task1a_shuffle_prototype}
  \sourcecode{snippets/random_utils.c}{Random function implementation.}{task1a_random}
  \sourcecode{snippets/int_shuffle.c}{Fisher-Yates shuffle algorithm.}{task1a_shuffle}

  \subsubsection{sort()}
  The sort function was implemented by using the widely known selection sort algorithm. The following snippet is the implementation of the sort function.
  \sourcecode{snippets/task1a_sort.c}{Integer sorting.}{task1a_sort}

  \clearpage

  \subsubsection{shoot()}
  All the \emph{shoot()} function does is generate a random number bounded by constant N. It then uses that random number as an index which will be passed onto the \emph{shoot\_value} member of \emph{myint\_t}. That index will then be zeroed out in the array.

  \sourcecode{snippets/int_shoot_header.c}{Shoot function prototype.}{task1a_shoot_prototype}
  \sourcecode{snippets/int_shoot_implementation.c}{Shoot function implementation.}{task1a_shoot}

  \subsubsection{target()}
  The \emph{target} function extracts the \emph{shoot\_value} from a \emph{myint\_t} variable and displays it. The first conditional statement checks if the array has been generated by checking if the first value in the int array is a -1. The second condition checks if the shoot value has been called previously. If all the checks pass, the shoot value will be printed to \emph{stdout}.
  \sourcecode{snippets/int_target.c}{Target function implementation.}{task1a_target}


  \subsection{Task 1b}
  The full code of task 1b can be seen in \emph{functions\_str.c} and \emph{functions\_str.h} respectively. The solution of task 1b is similar to the one of task 1a but slightly different to accommodate for strings.

  A global variable (however, doesn't have external linkage) called \emph{NUMS\_STR\_REPR} was used to represent the numbers from zero to ten. The good thing about this implementation is that the index of the element directly corresponds with its string value. A different struct will also be used to hold the strings and their shoot\_value, this struct will be called \emph{mystr\_t}.


  \sourcecode{snippets/mystr_t.c}{mystr\_t implementation}{mystr_t}


  \sourcecode{snippets/nums_str_repr.c}{nums\_str\_repr implementation}{nums_str_repr}


  \subsubsection{str\_create\_t()}
  Initializes a \emph{mystr\_t} variable.
  \sourcecode{snippets/str_create_t_header.c}{String Generate Prototype}{str_generate_prototype}
  \sourcecode{snippets/str_create.c}{String Generate Function}{str_generate}

  \subsubsection{str\_generate()}
  A loop starting from i (minimum number provided by the user) ending at 10 goes through the \emph{NUMS\_STR\_REPR} array and strcpy's it into the \emph{mystr\_t} member \emph{nums}.
  \sourcecode{snippets/str_generate_header.c}{str\_generate prototype}{str_generate_header}
  \sourcecode{snippets/str_generate.c}{str\_generate implementation}{str_generate}

  \clearpage

  \subsubsection{str\_shuffle()}
  The same principle used in the number version of the shuffle function. However the only difference is that we are using strcpy to swap values around.

  \sourcecode{snippets/str_shuffle_header.c}{str\_shuffle prototype}{str_shuffle_prototype}
  \sourcecode{snippets/str_shuffle.c}{str\_shuffle implementation}{str_shuffle_implementation}

  \subsubsection{str\_sort()}
  In this case, we are sorting the values depending on their context (for instance, ``ten'' comes after ``two'' even though lexicographically ``ten'' comes before ``two''). This is done by going through each values in the \emph{nums} array and comparing it with the elements in \emph{NUMS\_STR\_REPR}. Once the value is found, the index will be placed in an int array since the index directly corresponds to its value. Since the assignment asked for a sorted array to be returned, a variable of type \emph{mystr\_t} containing a sorted \emph{nums} array will be returned (non-destructive).

  \sourcecode{snippets/str_sort_header.c}{str\_sort prototype}{str_sort_prototype}
  \sourcecode{snippets/str_sort.c}{str\_sort implementation}{str_sort}

  As can be seen in listing \ref{lst: str_sort} we first go through each generated string and create another array with their integer representation. Then, the int array is sorted, changing the string array the exact same way the int array is being changed. The method used to convert a string array to its respective integer array is called \emph{str\_to\_int} (this can be seen in listing \ref{lst: str_sort})

  \subsubsection{str\_shoot()}
  This works exactly as its integer counterpart. But, instead of directly assigning the shoot value into the shoot value member in mystr\_t, we use strcpy. Kindly note that the constant EMPTY has been defined as ``empty''

  \sourcecode{snippets/str_shoot.c}{str\_shoot implementation}{str_shoot}

  \subsubsection{str\_target()}
  This works exactly as its integer couterpart. All it does is return \emph{shoot\_value} from the provided \emph{mystr\_t}.

  \sourcecode{snippets/str_target.c}{str\_target implementation}{str_target}

  \subsection{Task 1c}
  In this task, I glued together all of the functions and placed them into a menu-like interface so that the user may interact with it. It consists of validation.

  The code to the menu can be seen in listing \ref{lst: menu}

  \sourcecode{snippets/menu.c}{Menu code}{menu}

  This snippet is composed of a switch statement encapsulated in a do while loop (which allows the user to reinput their value and continue using the menu, even after the first interaction).

  All the \emph{menu\_print} function does is display what options the user can use in the interface.

  \sourcecode{snippets/menu_print.c}{menu\_print function}{menu_print}

  One may see which functions were mapped to which cases in the \emph{menu\_print} method.


  \clearpage

  \section{Task 2}
  The solution to this task can be found in the task2 directory where one may find both solutions to task 2a and task 2b. Since task 2a asked for a more limited approach, I took the liberty of using normal arrays. In task 2b I used queues constructed of linked lists to create a more dynamic solution. Task 2b also consists of more recursive functions.

  \subsection{Task 2a}
  \subsubsection{Structs used}

  \sourcecode{snippets/task2a_struct.c}{Structs used in task 2a}{task2a_structs}

  As seen in listing \ref{lst: task2a_structs}, two structs were used. The \emph{MsgQs\_t} was the data type which the assignment asked for. This struct contains the size (index) and an array of node pointers. The \emph{node} struct consists of a char* array, ID (identifier) and size.

  \clearpage

  \subsubsection{initializeMsgQs}
  Since the assignment asked for everything to be stored on heap, the data related to MsgQs\_t must have been completely malloced (and freed later).

  \sourcecode{snippets/initMsgQs_header.c}{initializeMsgQs function prototype}{initMsgQs_header}

  \sourcecode{snippets/initMsgQs.c}{initializeMsgQs function implementation}{initMsgQs}

  As can be seen in listing \ref{lst: initMsgQs}, all this function does is malloc the \emph{MsgQs\_t} struct enough memory and set its size (index) to 0. The pointer to the initialized struct is returned.

  \subsubsection{unloadMsgQs}
  This function frees all of the memory allocated to an entire MsgQs\_t. This is done by looping through every node and freeing every single message in it. Once all the messages are freed, so are the nodes themselves since they have still been allocated memory to hold the pointers. The MsgQs\_t will also be freed for the same reason.

  \sourcecode{snippets/unloadMsgQs_header.c}{unloadMsgQs header}{unloadMsgQs_header}
  \sourcecode{snippets/unloadMsgQs.c}{unloadMsgQs implementation}{unloadMsgQs}

  \subsubsection{createQ}
  The \emph{createQ} functions takes a MsgQs\_t which is to be populated, and an identifier which will identify each and every message queue. The method first checks if the message queue has reached its limit, if it hasn't, it will malloc enough memory to create a node and initialize it with all the necessary data. It will then increment the size of the message queue.

  \sourcecode{snippets/createQ_header.c}{createQ function prototype}{createQ_header}
  \sourcecode{snippets/createQ.c}{createQ function implementation}{createQ}

  \subsubsection{listQs}
  This method goes through a message queue's nodes and displays all of their messages. If the provided message queue is empty, the user will be notified. Otherwise, all of the messages will be printed to stdout.

  \sourcecode{snippets/listQs_header.c}{listQs function prototype}{listQs_header}
  \sourcecode{snippets/listQs.c}{listQs function implementation.}{listQs}

  \subsubsection{deleteQ}
  deleteQ goes through every node in the message queue until it finds a matching identifier, once it finds it, it will go through a simple freeing procedure to return the memory back to the heap. If the deleted node is intermediary, the rest of the nodes will be shifted back by one.
  \sourcecode{snippets/deleteQ_header.c}{deleteQ function prototype}{deleteQ_header}
  \sourcecode{snippets/deleteQ.c}{deleteQ implementation}{deleteQ}

  \subsubsection{sendMessage}
  sendMessage goes through every node in the message queue until it finds a matching identifier. Once it finds the node it was looking for, it will allocate enough memory to fit the string inside the node and will append it to the list. However, if a NULL is provided instead of an actual identifier, the sendMessageBatch method will be called instead (this can be done due to the fact that the argument which takes the ID is of type void*). Kindly note that the sendMessageBatch method will be covered in the next subsection.

    \sourcecode{snippets/sendIndividual.c}{sendIndividualMessage helper function}{sendInd}

  \sourcecode{snippets/sendMessage_header.c}{sendMessage function prototype}{sendMessage_header}

  \sourcecode{snippets/sendMessage.c}{sendMessage method implementation}{sendMessage}



  \subsubsection{sendMessageBatch}
  The sendMessageBatch method is similar to the sendMessage but instead of finding a select node to place the message in, it will place the message in every single node.

  \sourcecode{snippets/sendMessageBatch.c}{sendMessageBatch function implementation}{sendMessageBatch}


  \subsubsection{receiveMessage}
  The receiveMessage method displays a number of messages specified by the user starting from the rear of the queue (FIFO) and removes it. First, the node which is going to be interacted with is found and placed into a temporary variable called node (if identifier isn't found, the variable will be left as NULL). If the node is NULL, the method will return -1, signifying an error, otherwise it will display and remove messages until either the index (size) becomes 0 (exhausting the node) or the number of messages becomes 0.

  \sourcecode{snippets/receiveMessages.c}{receiveMessages function implementation}{receiveMessages}

  \subsubsection{purgeQs}
  purgeQs makes use of two helper functions which are:
  \begin{itemize}
  \item purgeIndividualNode - Goes through the provided node and frees all of its messages.
  \item purgeAllNodes - Goes through the provided message queue and calls purgeIndividualNode on every node in the message queue.
  \end{itemize}

  \sourcecode{snippets/purgeQs.c}{purgeQs function implementation}{purgeQs}

  purgeQs uses the same mechanism as sendMessage for handling single node purging or purging of an entire queue. This is done by using the void* mechanism which was previously described in sendMessage.



  \subsubsection{persistQ}
  This function simply checks if the node with the specified identifier exists and creates named after the identifier. First, the identifier is converted into a string and concatenated with the ``.dat'' extension. The largest 4 byte integer ($2^{32} - 1 = 4,294,967,295$ if signed) takes 10 bytes to be represented, add another four bytes for the extension and another byte for the null byte terminator. Meaning that the filename will consume a maximum of  15 bytes.

  If a node with the same ID has already been persisted, an error will be thrown. However, if it hasn't been persisted from before hand, it will just utilize the fputs method to write each message into the file, each message will be separated by a newline.

  \sourcecode{snippets/persistQ.c}{persistQ function implementation}{persistQ}
  \subsubsection{restoreQ}
  Since each message has been separated by a new line, the getline method has been used to extract the message from the file and pass it into a sendMessage method to repopulate the node.

  \sourcecode{snippets/restoreQ.c}{restoreQ function implementation}{restoreQ}

  \subsection{Task 2b}
  The solution of this task will be more dynamic than the previous. Queues made out of linked lists will be utilized. Most of the methods will also the written recursively as they are easier to visualize and write. This solution will also be provided as an ADT, meaning that the API (task2b\_functions.h) contains adequate documentation.

  \subsubsection{Structs used}

  Due to the complexity of  this solution (A queue of queues), a substantial amount of structs were created in order to ease the process of creating this solution. Each queue struct (MsgQs\_t and nodeMsg\_t) contains a size member, this is very useful for writing iterative solutions as opposed to recursive ones. One may also notice that each struct contains a common member called bytes. This member is supposed to store the  number of bytes written into it. This will help with RLP encoding later down the line. Since pre and post message delivery is encoded in RLP (and will be stored in the the struct containing RLP encoding) we need to ignore the number of bytes consumed by the RLP encoding itself.

  \sourcecode{snippets/task2b_structs.c}{Structs used in task2b (found in task2b\_structs.h)}{task2b_structs}

  \subsubsection{initializeMsgQs}
  This method returns an empty MsgQs\_t with some initialized values.

  \sourcecode{snippets/task2b/initializeMsgQs.c}{initializeMsgQs function implementation}{task2b_initializeMsgQs}

  \begin{longtable}{l p{10cm}}
    \explainline{2}{Allocate enough memory to the \emph{MsgQs\_t} struct.}
    \explainline{3}{Initialize the size of the message queue as 0.}
    \explainline{4-6}{Initialize the front and the rear of the message queue as NULL and return its pointer.}
  \end{longtable}

  \image{1}{images/gdbInitializeMsgQs.JPG}{The values of an initialized Message Queue (gdb output)}{initializeMsgQsOutput}

\clearpage
    \subsubsection{unloadMsgQs}
  This method makes use of the free\_node method which checks if the next node in the linked list is null, if it isn't null, it will call itself again but passes the next node in the linked list as an argument. This continues until the next node is NULL. Once the next node is NULL, all the items will be freed using the free\_item method which also uses tail recursion to free the individual items. Tail recursion was used as opposed to a normal iterative approach since an iterative approach would require a doubly linked list. However, using recursion, we can just go to the very last object of the linked list, free all of its contents (and the memory allocated for holding the pointers) and simply bubble up the recursion stack freeing everything else in the process.

  \sourcecode{snippets/task2b/free_node.c}{free\_node implementation}{free_node}
  \begin{longtable}{l p{10cm}}
    \explainline{5}{If the next node isn't null, pass the next node into the free\_node method.}
    \explainline{7}{Once the last node has been reached, the items inside of it will be freed recursively (in a similar manner to how the node is being freed).}
    \explainline{8}{Free the memory assigned to the node (pointers are allocated memory too).}
  \end{longtable}

  \clearpage

  \sourcecode{snippets/task2b/free_item.c}{free\_item implementation}{free_item}
  \begin{longtable}{l p{10cm}}
    \explainline{2}{Check if the next Item in the linked list isn't NULL}
    \explainline{3}{If the next node isn't null, pass it into the free\_item method recursively.}
    \explainline{4}{Free all of the contents of the Item}
    \explainline{5}{Bubble up the recursion stack, once the end if reached, the popped stack will return to line 3 and continue this process until the stack frame is empty.}
  \end{longtable}

  \clearpage

  \sourcecode{snippets/task2b/free_individual_item.c}{free\_individual\_item implementation}{free_ind_item}
  \sourcecode{snippets/task2b/unloadMsgQs.c}{unloadMsgQs method implementation}{unloadMsgQs}
  \begin{longtable}{l p{10cm}}
    \explainline{3-4}{Provide the free\_node method with the front of the message queue.}
    \explainline{5}{Set its size to 0 (since the message queue is being emptied.}
  \end{longtable}

  \image{1}{images/unloadMsgQsOutput.JPG}{unloadMsgQs results. As one may observe, the size is set to 0 and its members are all uninitialized.}{unloadMsgQsOutput}

\clearpage


  \subsubsection{createQ}
  % add description of contains_id
  The createQ method goes through a simple enqueue process to append the new node into the message queue.

  % place a snippet of contains_id
  % update createQ.c and free_item snippet
  \sourcecode{snippets/task2b/createQ.c}{createQ implementation}{task2b_createQ}

  \begin{longtable}{l p{10cm}}
    \explainline{3}{Check if the ID provided in the arguments exists}
    \explainline{4}{Return -1 if \emph{contains\_id} returns a 0.}
    \explainline{5-11}{Allocate enough memory to a temporary variable, set the next element in the linked list to NULL (this is done to identify that this is the most recent node), initialize the size to zero.}
    \explainline{13}{Checks if the message queue is empty}
    \explainline{14-15}{If the message queue is empty, set the front and the rear of the message queue to the temporary variable (the front and the rear both need to be initialized).}
    \explainline{17-18}{Otherwise, set the rear node's next pointer to tmp, then set the rear to tmp. This means that the newest element in the linked list is always on the rear and is always connected to the node preceeding it.}
  \end{longtable}

  The result of the method \emph{createQ(test, 110)}, test being an initialized MsgQs\_t pointer; (ie. it has been assigned to the result of initializeMsgQs) can be seen in figure \ref{fig: createQOutput}

  \image{1}{images/createQOutput.JPG}{createQ output.}{createQOutput}

  \clearpage

  \subsubsection{listQs}
  listQs is another recursive method which takes a nodeMsg\_t as its argument. Firstly, the size of the node is checked, if it's empty, the user will be notified. Otherwise, all the details will be printed using the listItems method. If the next node isn't null, we recursively call listQs again providing the next nodeMsg\_t as an argument. Once it reaches the the last nodeMsg\_t, the recursion stack will be popped from all of its stack frames.

  \sourcecode{snippets/task2b/printItem.c}{printItem helper function}{printItem}
  \sourcecode{snippets/task2b/listItems.c}{listItems helper function}{listItems}

  \begin{longtable}{l p{10cm}}
    \explainline{1}{Arguments takes the front of a nodeMsg\_t queue.}
    \explainline{2}{Display the item provided in the argument.}
    \explainline{3}{Check if there is another item in the item linked list.}
    \explainline{4}{Recursively call listItems with the next item in the item linked list.}
    \explainline{5}{Bubble up the recursion stack.}
  \end{longtable}
  \clearpage

  \sourcecode{snippets/task2b/listQs.c}{listQs method implementation}{listQs}
  \begin{longtable}{l p{10cm}}
    \explainline{2}{front argument takes the front of a MsgQs\_t queue.}
    \explainline{3}{Check if the node is empty.}
    \explainline{6-7}{ print the ID of the node and use listItems (providing the front of  the nodeMsg\_t).}
    \explainline{9}{Check if the next node isn't null.}
    \explainline{10}{recursively call listQs with the next node in the linked list.}
    \explainline{12}{Bubble up the recursion stack.}
  \end{longtable}

  \image{0.5}{images/listQOutput.JPG}{Output Listing of listQs(). In this figure one may observe that text which was previously inputted has been displayed}{listQOutput}

  \clearpage

  \subsubsection{deleteQ}
  In deleteQ, the front of the MsgQs\_t provided is first checked to see if it matches with the specified identifier (this is done to avoid going into extra recursive methods). If the front of message queue provided matches the specified identifier, it will be freed and the front assigned to the next item linked to the freed item.
  \sourcecode{snippets/task2b/deleteQ.c}{deleteQ method implementation}{task2b_deleteQ}

  \begin{longtable}{l p{10cm}}
    \explainline{2}{Check if the front of the message queue matches the specified identifier.}
    \explainline{3}{Create a temporary variable which holds the front (it's easier to write temp->front rather than q->front->front).}
    \explainline{4}{ Call the recursive method free\_item providing the front of the node.}
    \explainline{5}{Reassign the front of the message queue to the next node so that the front won't be empty.}
    \explainline{6}{Return a success status.}
    \explainline{8}{Call the recursive method removeQ, providing the front of the message queue and the specified identifier.}
  \end{longtable}

  \clearpage

   \sourcecode{snippets/task2b/removeQ.c}{removeQ helper function}{removeQ}

   \begin{longtable}{l p{10cm}}
    \explainline{6-7}{Check if the next node is NULL, if it is, a failure status will be returned (one might think that the last node isn't being checked, but since the first node provided to removeQ has already been checked outside of removeQ, we will always check if the next node's ID matches the specified identifier).}
    \explainline{9}{Does the next node's ID match the specified identifier?}
    \explainline{11}{ Set its size to 0 since we are emptying it.}
    \explainline{12}{Free all of the items it contains.}
    \explainline{15}{Reassign the next pointer variable to the next nodes next pointer (this way, everything will remain linked).}
    \explainline{17}{Free the node from  memory allocated to its members .}
    \explainline{18}{Return a success status.}
    \explainline{27}{Recursively call removeQ providing the next node in the provided nodeMsg\_t's linked list. If it hasn't been found, -1 will bubble up the recursion stack, otherwise, 1 will bubble up the recursion stack without having to go through all the other elements.}
  \end{longtable}

  In this example, the method \emph{deleteQ(test, 96)} will be called, test being the initialized message queue, and 96 being the ID of the node.

  \image{1}{images/deleteQProof.JPG}{Proof that a node with ID 96 has been created.}{deleteQQueueProof}

  \image{1}{images/deleteQOutput.JPG}{One can see that the rear node which previously had the ID of 96 is now uninitialized.}{deleteQOutput}

  \clearpage

  \subsubsection{RLP}
  Before I describe the rest of the methods, I think that it is important to describe how I have implemented RLP\footnote{Ethereum RLP wiki: \url{https://github.com/ethereum/wiki/wiki/RLP}} encoding and decoding since from here on out, RLP will be used. In listing \ref{lst: rlp.c}, one may find all of the code related to RLP procedures.

  \sourcecode{snippets/task2b/rlp.c}{RLP Implementation}{rlp.c}

  \begin{longtable}{l p{10cm}}
    \explainline{11}{Measure the number of bytes a number takes.}
    \explainline{25}{Pass the number into a log2 function (binary is base 2, this will help us find the number of bits), floor it to round down and add 1 to make up for any truncated bits.}
    \explainline{26}{Divide the value obtained in line 25 by 8 to convert bits to bytes and find its ceiling since you cannot have a fraction of a bit.}
    \explainline{34}{This method will be used to encode both lists and strings with a payload greater than 55 bytes. They were grouped together due to their similarities, the only difference being their offset.}

    \explainline{36}{Find the number of bytes the length occupies.}
    \explainline{37-38}{Allocate enough memory to represent the encoding (number of bytes taken by length, a byte taken by the offset and another byte taken by the null byte).}
    \explainline{40-41}{Assign the first byte as the sum of the offset and the number of bytes the length consumes. Assign the last byte as a null byte.}
    \explainline{43}{The only remaining elements in the buffer array are the ones in the middle. Since integers are read using big endian, the MSB (most significant bit) will be on the left most side. buffer\_size - 1 represents the null byte, therefore, the next empty bit will be found in buffer\_size - 2 since all the bytes in the middle are empty. The for loop is also conditioned to stop when the number is smaller than or equal to 0, meaning that only the numbers between 0 and buffer\_size - 1 will be created.\\}
    \explainline{44}{I took a bit fiddling approach in order to break down an int into its respective bytes. Since i is starting from the last empty slot in the buffer, it will contain the last 8 bits (the LSBs), this will be done by truncating the int and taking the last 8 bits. With every iteration, i moves to the next empty slot and j increases by 1, meaning the int will by shifted by 8*j (to fit in the next 8 bits). A char will always take the last 8 bits of an integer, so to create multiple chars out of an integer, we need to shift by 8 to deconstruct the int. Kindly look at figure \ref{fig: 2bytearray} for a visual representation.\\}
    \explainline{51-56}{If the string is less than 56 characters long, return a 2 byte char array with the first byte as the offset 0x80 + string length and the second byte as a null byte.}
    \explainline{57-59}{Otherwise use long object encoding.}
    \explainline{80-82}{char array of size 1 is self encoding.}
    \explainline{83-85}{char array of size greater than 1 and less than 56 has an encoding of 0x80 plus its size.}
    \explainline{87}{char array of size greater than 55 will just call encode_long_object with an offset of 0xb7.}
    \explainline{89}{Concatenate the message with the encoding.}
    \explainline{92-103}{Identical to lines 73-90 but with different offsets.}

   \end{longtable}

   \image{1}{images/16bitarray.png}{Visual representation of byte stuffing algorithm.}{2bytearray}

   \clearpage

  \subsubsection{sendMessage}

   \sourcecode{snippets/task2b/sendMessage.c}{sendMessage method implementation}{task2b_sendMessage}

   \begin{longtable}{l p{10cm}}
     \explainline{1}{sendMessage requires a message queue, ID to send message to (which can be null to signify that sendMessageBatch will be used instead), sender, subject and content }

     \explainline{5-7}{If the ID provided is NULL, pass the arguments into the sendMessageBatch method. This will return a success status.}

     \explainline{9}{Call the recursive method populate\_individual\_node. }


  \end{longtable}

  \clearpage

   \sourcecode{snippets/task2b/populateIndividualNode.c}{populate\_individual\_node helper function}{popindnode}

   \begin{longtable}{l p{10cm}}
     \explainline{4-5}{Check if the provided node is NULL (meaning that the createQ method hasn't been called yet), if it is NULL, return a failure status.}

     \explainline{8}{Check if the node's ID matches the specified identifier.}

     \explainline{9}{Enqueue the node by calling enqueue\_nodeMsg\_t. }

     \explainline{18}{Check if the next node isn't NULL (check if there is another node in the linked list). }

     \explainline{19}{Recursively call populate\_individual\_node again providing the next node in the linked list (and bubble the result up the recursion stack). }

  \end{longtable}

  \clearpage

   \sourcecode{snippets/task2b/enqueue_nodeMsg_t.c}{enqueue\_nodeMsg\_t helper function}{enqueue_nodeMsg_t}

   \begin{longtable}{l p{10cm}}
     \explainline{3-4}{Create an Item (content of nodeMsg\_t).}

     \explainline{6}{Is the queue not empty?}

     \explainline{7}{Set the current rear's next value as the newly created Item. }

     \explainline{8}{Set the rear as the newly created Item.}

     \explainline{10}{If the queue is empty, set the front and the rear as the newly created Item.}

   \end{longtable}

   \clearpage

   \sourcecode{snippets/task2b/create_item.c}{create\_item helper function}{create_item}

   \begin{longtable}{l p{10cm}}
     \explainline{2}{Allocate enough memory to hold the members of the Item struct.}

     \explainline{3}{Allocate enough memory to hold the message and it's RLP encoding.}

     \explainline{4}{Allocate enough memory to hold the members of the Message struct. }

     \explainline{5-6}{Allocate enough memory to contain the rlp encoded subject and content.}

     \explainline{8-9}{Since we are placing rlp encoded strings into the item from the get go, we need to find the number of bytes which the variable holds without the rlp encoding. By adding the number of characters written and assigning them to a variable, we can keep track of this. This will also help with encoding down the line}

     \explainline{11}{Place the current time in the Item.}

     \explainline{12-14}{Encode the sender, message and content in RLP by calling the rlp\_encode\_str method which creates the RLP encoding and concatenates it with the actual char* provided.}

     \explainline{15}{Set the next Item in the linked list as null, this will be necessary for the recursive methods. }


     \explainline{17}{Return a pointer to the created item. }

   \end{longtable}

   \clearpage

   \subsubsection{sendMessageBatch}

   \sourcecode{snippets/task2b/sendMessageBatch.c}{sendMessageBatch method implementation}{task2b_sendMessageBatch}


    \sourcecode{snippets/task2b/batchPopulateNode.c}{batchPopulateNode helper function}{batchPopulateNode}

    \begin{longtable}{l p{10cm}}
      \explainline{3-4}{If the node is null, bubble up the recursion stack.}
      \explainline{5}{Enqueue the node.}
      \explainline{6}{If the next node isn't null, recursively call batch\_populate\_node providing the node in the next pointer.}
      \explainline{7}{Go up the stack.}


   \end{longtable}


   \subsubsection{receiveMessages}

   \sourcecode{snippets/task2b/receiveMessages.c}{receiveMessages method implementation}{task2b_receiveMessages}

   \begin{longtable}{l p{10cm}}
      \explainline{11-12}{Go through every single node in the message queue until a node with a matching ID is found.}
      \explainline{13-14}{Wrap num\_of\_messages if it exceeds the max number of messages available.}
      \explainline{16-21}{Display the message, relinquish it of its resources, change the front of the queue to the next message to keep a functional linked list and reduce the size..}
      \explainline{25-26}{Otherwise, set the temporary variable front as the next node in the message queue.}
   \end{longtable}
   \subsubsection{purgeQs}
   If the provided ID is null, purge all of the nodes, otherwise, check if the front of the message queue matches the identifier specified, if it doesn't, call empty\_q, which will find the node and relinquish it of its resources.
   \sourcecode{snippets/task2b/purgeQs.c}{purgeQs method implementation}{task2b_purgeQs}

   \begin{longtable}{l p{10cm}}
     \explainline{7-11}{If the node at the front of the message queue matches the specified ID, it will be freed and the front of the message queue will be replaced with the next node in the queue.}
   \end{longtable}


    \sourcecode{snippets/task2b/empty_all_qs.c}{empty\_all\_qs helper function}{empty_all_qs}

   \begin{longtable}{l p{10cm}}
     \explainline{4-5}{Free all of the items in the node and set its size to 0.}
     \explainline{6-7}{If the next node isn't NULL, recursively call empty\_all\_qs with the next node in the linked list.}
   \end{longtable}

   \sourcecode{snippets/task2b/empty_q.c}{empty\_q helper function}{empty_q}

   \begin{longtable}{l p{10cm}}
     \explainline{4-5}{If the next node is NULL, return a failure status.}
     \explainline{7-11}{If the next node's matches, set its size to zero and relinquish its resources.}
     \explainline{20}{If the next node isn't NULL or doesn't match, recursively call empty\_q with the next node in the linked list. This will also bubble the returned status up the recursion stack.}
   \end{longtable}

   \subsubsection{persistQ}
   \sourcecode{snippets/task2b/persistQs.c}{persistQs method implementation}{task2b_persistQs}
      \begin{longtable}{l p{10cm}}
     \explainline{23-36}{Find the node which matches the ID.}
     \explainline{38}{Simply sum the bytes member of every Item and assign it to the node's bytes member.}
     \explainline{43-50}{Concatenate the ID and the ``.dat'' extension and check if a file with that name already exists, if so, return a failure status.}
     \explainline{51-52}{Create the list encoding for a node and write it into the file.}
     \explainline{55-69}{Encode the item struct payload and write it into the file, write the sender (recall that everything is RLP encoded on creation), time of expiry and its encoding (has to be treated as a long object since an integer is 4 bytes), write the list encoding for the message structure and write the subject and content into the file. Lastly, move onto the next Item in the linked list.}
     \explainline{70}{Close the stream.}
   \end{longtable}

   \clearpage

   \subsubsection{restoreQ}
   The strategy behind decoding the RLP encoded text consists of skipping every list encoding found and associating data with the order it was written, once one analyzes the written data, it is easy to see that there is a pattern which can be followed. If one skips the first list encoding, decodes the string encoding for the sender, decodes the encoding for the expiry, skips the next list encoding, decodes the subject and decodes the content and goes to the second step until all the data has been read, all the data will be decoded. The decoded data is passed into the sendMessage method.

   \sourcecode{snippets/task2b/restoreQ.c}{restoreQ method implementation}{task2b_restoreQ}
   \begin{longtable}{l p{10cm}}
     \explainline{12}{Skip the node list encoding by moving the file pointer over it.}
     \explainline{23}{Check if a file reading error has been thrown after the previous skip\_list, if an error is thrown, this indicates that the EOF has been reached.}
   \end{longtable}

   \sourcecode{snippets/task2b/file_functions.c}{Helper functions used to decode from the previously RLP encoded file.}{file_functions}
   \begin{longtable}{l p{10cm}}
     \explainline{7}{Get the list encoding.}
     \explainline{8-14}{If between 0xc0 and 0xf7, the list is self encoding.}
     \explainline{15-21}{If the payload is greater than 55, find the byte length (which will determine to the number of characters to skip), a call fgetc (which also moves the file pointer by a character) until we've reached the last byte. Don't forget that fgetc will always return the value of the next char in the pointer.}
     \explainline{25-30}{Get the first character and read the next 4 bytes as a long int.}
     \explainline{37-38}{Get the offset.}
     \explainline{40-45}{If the offset is less than 0x80, it is self encoding, return a char* containing the character and a null byte.}
     \explainline{45-52}{If the offset is between 0x80 and 0xb8 (length less than 56 bytes), then call fread on the length of the string (fread behaves like fgetc ie. the file pointer will still be moved).}
     \explainline{53-57}{If the length is greater than 55 bytes, get the byte length, shift each byte accordingly and OR it with the size, that way, the bytes which have been deconstructed are stuffed back into a 4 byte variable.}
     \explainline{59-61}{Read the remaining text and return it.}
   \end{longtable}

   \subsection{Limitations and known bugs}
   Due to how the standard libraries are written, more specifically, strlen, returns a value of type size\_t (which is an unsigned int). Using strlen, we are limiting the number of bytes which a length can be represented by to 4 bytes instead of the 7 bytes.

   Another limitation and known bug due to the use of strcpy and strcat is that if a string or list with a payload greater than 55 which is a multiple of 256 will lead to faulty decoding since all multiples of 256 have their last 8 bits as 0x00 (which is also a null byte). Meaning that strcpy and strcat will overwrite this null byte changing the length. A solution to this would be to painstakingly use memcpy instead of the standard str methods.

   \subsection{Task 2c}
   One may find a full test driver for task 2c linked to the ADT shared library in a file called task2\_main, under the task2 directory.



\end{onehalfspacing}
% ---------------   End  ----------------
\end{document}